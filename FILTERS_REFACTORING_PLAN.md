# План рефакторинга фильтров основного расписания

## Обзор

Данный документ описывает план переписывания системы фильтров для основного расписания (`SchedulePage`) с учетом лучших практик фронтенд-разработки и архитектуры Feature-Sliced Design (FSD).

## Текущее состояние

### Расположение фильтров
Фильтры находятся в `features/manageAccountSchedule`:
- `ui/FiltersBar.tsx` - компонент отображения активных фильтров в виде бейджей
- `ui/AccountFilters.tsx` - основной компонент-обертка фильтров
- `ui/AccountFilterForm.tsx` - форма фильтров в модальном окне
- `model/filterTransform.ts` - трансформация данных между формами, URL и API
- `lib/filterUtils.ts` - утилиты для работы с фильтрами (теги, подсчет активных)
- `lib/useFiltersFromUrl.ts` - хук для синхронизации фильтров с URL параметрами

### Текущие особенности
1. **Синхронизация с URL**: Фильтры сохраняются в URL параметрах для возможности шаринга и восстановления состояния
2. **Множественные типы фильтров**: 
   - Период (date range)
   - Множественный выбор (pokerNetworkIds, gameTypeIds, approxLimitIds, maintenanceIds, markerIds, gamingMachineIds, accountIds, cupIds)
   - Одиночный выбор (locationId, groupType)
   - Enum-типы (accountTypes, maintenanceTypeSelector)
3. **Динамическая загрузка опций**: Опции фильтров загружаются с сервера на основе текущих значений фильтров
4. **Обработка удаленных элементов**: Отображение удаленных элементов с пометкой "deleted"
5. **Сложная логика трансформации**: Преобразование между формами (AccountFiltersForm), URL параметрами (FilterValues) и API запросами (Filter)

## Проблемы текущей реализации

1. **Нарушение принципов FSD**: 
   - Логика трансформации данных смешана с бизнес-логикой
   - Отсутствует четкое разделение на слои (model/lib/ui)
   - Утилиты фильтров находятся в `lib`, но используются только в одном месте

2. **Дублирование кода**:
   - Повторяющаяся логика для разных типов фильтров в `ControlledMultiSelect`
   - Похожие паттерны обработки данных в разных местах

3. **Сложность поддержки**:
   - Большой монолитный компонент `AccountFilterForm.tsx` (1248 строк)
   - Сложная логика синхронизации состояния между формой, URL и API
   - Множественные `useEffect` и `useMemo` с зависимостями

4. **Тестируемость**:
   - Сложно тестировать из-за тесной связанности компонентов
   - Логика трансформации смешана с UI логикой

5. **Производительность**:
   - Множественные ре-рендеры из-за сложных зависимостей
   - Неоптимальная работа с мемоизацией

## План рефакторинга

### 1. Реорганизация структуры по FSD

#### 1.1 Выделение сущностей (entities)
Создать `entities/filter` для базовых типов и интерфейсов:
```
entities/filter/
  ├── model/
  │   ├── types.ts          # Базовые типы фильтров
  │   └── constants.ts      # Константы фильтров
  └── index.ts
```

#### 1.2 Реорганизация фичи (features/manageAccountSchedule)
Улучшить структуру существующей фичи:
```
features/manageAccountSchedule/
  ├── model/
  │   ├── filters/
  │   │   ├── types.ts              # Типы специфичные для AccountFilters
  │   │   ├── transform.ts           # Трансформация данных (выделить из filterTransform.ts)
  │   │   ├── normalize.ts          # Нормализация данных
  │   │   ├── validation.ts         # Валидация фильтров
  │   │   └── constants.ts          # Константы и дефолтные значения
  │   ├── hooks/
  │   │   ├── useFiltersFromUrl.ts  # Хук синхронизации с URL
  │   │   ├── useFilterOptions.ts   # Хук загрузки опций фильтров
  │   │   └── useFilterState.ts     # Хук управления состоянием фильтров
  │   └── ...
  ├── lib/
  │   ├── filters/
  │   │   ├── filterUtils.ts        # Утилиты для работы с фильтрами
  │   │   ├── filterTags.ts         # Логика генерации тегов фильтров
  │   │   └── filterCount.ts        # Подсчет активных фильтров
  │   └── ...
  ├── ui/
  │   ├── filters/
  │   │   ├── FiltersBar.tsx        # Компонент активных фильтров
  │   │   ├── FiltersButton.tsx     # Кнопка открытия фильтров
  │   │   ├── FilterModal.tsx       # Модальное окно фильтров
  │   │   ├── FilterForm.tsx        # Форма фильтров (разбить на части)
  │   │   ├── fields/
  │   │   │   ├── DateRangeField.tsx
  │   │   │   ├── MultiSelectField.tsx
  │   │   │   ├── SingleSelectField.tsx
  │   │   │   └── EnumSelectField.tsx
  │   │   └── ...
  │   └── ...
  └── ...
```

### 2. Разделение ответственности

#### 2.1 Model слой
- **Трансформация данных**: Четкое разделение на функции преобразования между форматами
- **Валидация**: Выделение логики валидации в отдельные функции
- **Нормализация**: Унификация данных перед отправкой/получением

#### 2.2 UI слой
- **Композиция компонентов**: Разбить большой `AccountFilterForm` на мелкие переиспользуемые компоненты
- **Управление состоянием**: Использовать React Hook Form для управления формой
- **Оптимизация рендеров**: Мемоизация компонентов и колбэков

### 3. Улучшение архитектуры

#### 3.1 Паттерн Strategy для типов фильтров
Создать единый интерфейс для разных типов фильтров:
```typescript
interface FilterFieldStrategy {
  serialize: (value: any) => string;
  deserialize: (value: string) => any;
  validate: (value: any) => boolean;
  getDefaultValue: () => any;
}
```

#### 3.2 Factory для создания полей фильтров
Упростить создание полей фильтров через фабрику:
```typescript
createFilterField(type: FilterFieldType, config: FieldConfig): FilterFieldComponent
```

#### 3.3 State Management
- Использовать React Hook Form для управления формой
- Синхронизация с URL через отдельный хук
- Оптимизация обновлений через debounce/throttle

### 4. Оптимизация производительности

#### 4.1 Мемоизация
- Мемоизация опций фильтров
- Мемоизация вычисляемых значений
- Использование `useMemo` и `useCallback` где необходимо

#### 4.2 Debounce для API запросов
- Добавить debounce для запросов опций фильтров при изменении значений
- Оптимизировать количество запросов к API

#### 4.3 Виртуализация списков
- Для больших списков опций (например, accounts) использовать виртуализацию

### 5. Улучшение UX

#### 5.1 Улучшение UX
- Показывать ошибки валидации сразу при вводе
- Предупреждать о некорректных значениях

#### 5.2 Сохранение состояния
- Сохранение фильтров в localStorage для быстрого восстановления
- Возможность сохранения пресетов фильтров

#### 5.3 Улучшение доступности
- Правильные ARIA атрибуты
- Поддержка клавиатурной навигации
- Screen reader friendly

### 6. Тестирование

#### 6.1 Unit тесты
- Тесты для трансформации данных
- Тесты для утилит фильтров
- Тесты для хуков

#### 6.2 Integration тесты
- Тесты для компонентов фильтров
- Тесты для синхронизации с URL

#### 6.3 E2E тесты
- Тесты для полного flow работы с фильтрами

## Детальный план реализации

### Этап 1: Подготовка инфраструктуры
1. Создать структуру папок согласно FSD
2. Выделить базовые типы в `entities/filter`
3. Создать константы и дефолтные значения

### Этап 2: Рефакторинг model слоя
1. Разделить `filterTransform.ts` на отдельные модули:
   - `transform.ts` - трансформация данных
   - `normalize.ts` - нормализация
   - `validation.ts` - валидация
2. Создать стратегии для разных типов фильтров
3. Оптимизировать хуки (`useFiltersFromUrl`, `useGetFilters`)

### Этап 3: Рефакторинг UI слоя
1. Разбить `AccountFilterForm` на компоненты:
   - `DateRangeField` - поле периода
   - `MultiSelectField` - множественный выбор
   - `SingleSelectField` - одиночный выбор
   - `EnumSelectField` - выбор enum значений
2. Создать композиционные компоненты
3. Оптимизировать рендеринг

### Этап 4: Оптимизация и улучшения
1. Добавить debounce для API запросов
2. Оптимизировать мемоизацию
3. Улучшить обработку ошибок
4. Добавить loading состояния

### Этап 5: Тестирование и документация
1. Написать unit тесты
2. Написать integration тесты
3. Обновить документацию
4. Code review

## Ожидаемые результаты

### Улучшения архитектуры
- ✅ Четкое разделение ответственности по слоям FSD
- ✅ Переиспользуемые компоненты и утилиты
- ✅ Упрощенная поддержка и расширение функциональности

### Улучшения производительности
- ✅ Меньше ре-рендеров
- ✅ Оптимизированные API запросы
- ✅ Быстрая работа с большими списками опций

### Улучшения качества кода
- ✅ Меньше дублирования кода
- ✅ Улучшенная тестируемость
- ✅ Более понятная структура кода

### Улучшения UX
- ✅ Более отзывчивый интерфейс
- ✅ Лучшая обработка ошибок
- ✅ Улучшенная доступность

## Риски и митигация

### Риск 1: Регрессии в функциональности
**Митигация**: 
- Тщательное тестирование на каждом этапе
- Постепенный рефакторинг с сохранением обратной совместимости
- Code review

### Риск 2: Увеличение времени разработки
**Митигация**:
- Поэтапная реализация
- Приоритизация критичных улучшений
- Использование существующих паттернов проекта

### Риск 3: Сложность миграции
**Митигация**:
- Сохранение существующих интерфейсов где возможно
- Постепенная миграция компонентов
- Документирование изменений

## Заключение

Данный план рефакторинга направлен на улучшение архитектуры фильтров с соблюдением принципов FSD и лучших практик фронтенд-разработки. Реализация будет происходить поэтапно с сохранением работоспособности системы на каждом этапе.
